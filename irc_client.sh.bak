#!/bin/bash
#
# ZigzagDownLoader (ZDL)
# 
# This program is free software: you can redistribute it and/or modify it 
# under the terms of the GNU General Public License as published 
# by the Free Software Foundation; either version 3 of the License, 
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see http://www.gnu.org/licenses/. 
# 
# Copyright (C) 2011: Gianluca Zoni (zoninoz) <zoninoz@inventati.org>
# 
# For information or to collaborate on the project:
# https://savannah.nongnu.org/projects/zdl
# 
# Gianluca Zoni (author)
# http://inventati.org/zoninoz
# zoninoz@inventati.org
#

TEXTDOMAINDIR=/usr/local/share/locale
TEXTDOMAIN=zdl
export TEXTDOMAINDIR
export TEXTDOMAIN

source /usr/bin/gettext.sh

path_usr="/usr/local/share/zdl"
path_tmp=".zdl_tmp"
gui_log="$path_tmp"/gui-log.txt

source $path_usr/libs/core.sh
source $path_usr/libs/utils.sh
source $path_usr/libs/downloader_manager.sh
source $path_usr/libs/log.sh
source $path_usr/config.sh
get_conf

[ -z "$background" ] && background=tty
source $path_usr/ui/widgets.sh

file_log="zdl_log.txt"
name_prog=ZigzagDownLoader

if [ -f "$file_log" ]
then
    log=1
fi

function start_timeout {
    local start=$(date +%s)
    local now
    local diff_now
    local max_seconds=60
    if [ -d /cygdrive ]
    then
	max_seconds=120
    fi
 
    
    touch "$path_tmp/irc-timeout"
    sed -r "/^${url_in//\//\\/}$/d" -i "$path_tmp/irc-timeout" 
    
    for i in {0..12}
    do
	now=$(date +%s)
	diff_now=$(( now - start ))

	if grep -P "^$url_in$" "$path_tmp/irc-timeout" &>/dev/null
	then                 
	    exit

	elif (( diff_now >= $max_seconds ))
	then            
            touch "$test_xfer"
	    sed -r "/^.+ ${url_in//\//\\/}$/d" -i "$path_tmp/irc-timeout" 
	    kill_url "$url_in" 'xfer-pids'
	    kill_url "$url_in" 'irc-pids'

            del_pid_url "$url_in" "irc-wait"
	    exit
	fi
		
	sleep 10
    done &
}

function set_mode {
    this_mode="$1"
    printf "%s $s\n" "$this_mode" "$url_in" >>"$path_tmp/irc_this_mode"
}

function get_mode {
    this_mode=$(grep "$url_in$" "$path_tmp/irc_this_mode" | cut -d' ' -f1)
    [ -z "$this_mode" ] && this_mode=stdout
}

function xdcc_cancel {
    # [ -z "$ctcp_src" ] &&
    # 	ctcp_src=$(grep "$url_in" "$path_tmp"/irc_xdcc 2>/dev/null |
    # 			  cut -d' ' -f1 | tail -n1)
    irc_send "PRIVMSG $ctcp_src" "XDCC CANCEL"
    irc_send "PRIVMSG $ctcp_src" "XDCC REMOVE"
    kill_url "$url_in" "xfer-pids"
}

function irc_quit {
    local pid_list
    touch "$test_xfer"
    
    [ -f "$path_tmp/${file_in}_stdout.tmp" ] &&
	kill $(head -n1 "$path_tmp/${file_in}_stdout.tmp") 2>/dev/null

    xdcc_cancel
    exec 4>&-
    irc_send "QUIT"
    exec 3>&-

    #kill_url "$url_in" "irc-pids"
    
    if [ -d /cygdrive ]
    then
    	pid_list=( $(children_pids $PID) $PID )

    else
    	pid_list=( $(ps -o pid --no-headers --ppid $PID) $PID )
    fi

    for pid in ${pid_list[@]} 
    do
	kill -9 $pid
    done &

    exit 1
}

function irc_send {
    printf "%s\r\n" "$*" >&3
}


function irc_ctcp {
    local pre=$1
    local post=$2
    ## \015 -> \r ; \012 -> \n

    printf "%s :\001%s\001\015\012" "$pre" "$post" >&3
}

# function get_irc_code {
#     local msg="$1"
#     local code
#     #code=$(grep -h "$msg" $path_usr/irc/* |
# 		  # cut -d' ' -f1 |
# 		  #     head -n1) 
#     code=$(awk "/$msg/{print $1}" $path_usr/irc/*)
#     ## metodo alternativo (rivedere codifica dei file dei messaggi in $path_usr/irc/)
#     # [[ "$(cat $path_usr/irc/*)" =~ ([0-9]+)' "'[^\"]*$msg ]] &&
#     # 	code=${BASH_REMATCH[1]}

#     if [[ "$code" =~ ^[0-9]+$ ]]
#     then
# 	printf "%d" "$code"
# 	return 0

#     else
# 	return 1
#     fi
# }

# function get_irc_code {
#     local msg="$1"
#     local code
#     echo "$msg"
#     awk -v msg="$msg" '{match($0, /\"([^\"]+)\"/, pattern); if (match(msg, pattern[1])) {print pattern[1]}}' $path_usr/irc/*
# }

function check_notice {
    local chan
    notice="$1"
    notice2=${notice%%:*}
    notice2=${notice2%%','*}
    notice2=${notice2%%[0-9]*}
    notice2=${notice2%%SEND*}
    notice2=$(trim "$notice2")

    if [ "$errors_again" != "${errors_again//$notice2}" ]
    then
	_log 27
	irc_quit
    fi

    if [ "$errors_stop" != "${errors_stop//$notice2}" ]
    then
	_log 29
	irc_quit
    fi

    # if [[ "$notice" =~ 'JOIN #'([^\ ]+) ]]
    # then
    # 	chan="${BASH_REMATCH[1]}"
    # 	print_c 2 "/JOIN #${chan}"
    # 	irc_send "JOIN #${chan}"
    # fi
}

function check_ctcp {
    local irc_code key
    unset ctcp_msg 

    ctcp_msg=( $(tr -d "\001\015\012" <<< "$*") )
    local new=$(awk '!($0 in a){a[$0]; print}' "$path_tmp"/irc_xdcc)
    echo "$new" > "$path_tmp"/irc_xdcc

#    if [ -z "$ctcp_src" ]
#    then
#        ctcp_src=$(grep "$url_in" "$path_tmp"/irc_xdcc 2>/dev/null |
        #		   cut -d' ' -f1)
        ctcp_src="${url_in#*'%20'}"
        ctcp_src="${ctcp_src%%'%20'*}"
#    fi
    ########### codice del msg: 
    # irc_code=$(get_irc_code "${ctcp_msg[*]}")
    # case $irc_code in
    # 	743|883|878|879|1124|1131)
    # 	    irc_quit
    # 	    ;;
    # esac

    if [ "${ctcp_msg[0]}" == 'DCC' ] &&
	   [ -n "$ctcp_src" ]
    then
	if [ "${ctcp_msg[1]}" == 'ACCEPT' ]
	then
	    print_c 1 "CTCP<< PRIVMSG $ctcp_src :${ctcp_msg[*]}"
	    set_resume
	
	elif [ "${ctcp_msg[1]}" == 'SEND' ]
	then
	    print_c 1 "CTCP<< PRIVMSG $ctcp_src :${ctcp_msg[*]}"
	    
	    ctcp[file]="${ctcp_msg[2]}"
	    ctcp[address]="${ctcp_msg[3]}"
	    ctcp[port]="${ctcp_msg[4]}"
	    ctcp[size]="${ctcp_msg[5]}"
	    ctcp[offset]=$(size_file "${ctcp[file]}")
	    [ -z "${ctcp[offset]}" ] && ctcp[offset]=0
            unset ctcp_src
	    if ctcp[address]=$(check_ip_xfer "${ctcp[address]}") &&
		    [[ "${ctcp[port]}" =~ ^[0-9]+$ ]]
	    then
		return 0
	    fi
	fi
    fi
    unset ctcp_src
    return 1
}

function set_resume {
    echo "$url_in" >>"$path_tmp"/irc_xdcc_resume
}

function get_resume {
    if [ -f "$path_tmp"/irc_xdcc_resume ]
    then
	grep -P "^$url_in$" "$path_tmp"/irc_xdcc_resume &>/dev/null
    fi
}

function init_resume {
    if [ -f "$path_tmp"/irc_xdcc_resume ]
    then
	sed -r "/^${url_in//\//\\/}$/d" -i "$path_tmp"/irc_xdcc_resume
    fi
}

function check_dcc_resume {
    if [ -f "${ctcp[file]}" ] &&
	   [ -f "${ctcp[file]}.zdl" ] &&
	   [ "$(cat "${ctcp[file]}.zdl")" == "$url_in" ] &&
	   (( ctcp[offset]<ctcp[size] ))
    then

	irc_ctcp "PRIVMSG $ctcp_src" "DCC RESUME ${ctcp[file]} ${ctcp[port]} ${ctcp[offset]}" >&3
	print_c 2 "CTCP>> PRIVMSG $ctcp_src :DCC RESUME ${ctcp[file]} ${ctcp[port]} ${ctcp[offset]}" 

	for ((i=0; i<10; i++))
	do		    
	    if [ -f "$path_tmp"/irc_xdcc_resume ] &&
		   get_resume
	    then
		init_resume
		return 0
	    fi
	    sleep 1
	done
    fi
    return 1
}

function check_ip_xfer {
    local ip_address="$1"

    if [[ "$ip_address" =~ ^[0-9]+$ ]]
    then
	ip_address=$(dotless2ip $ip_address)
	
    elif [[ "$ip_address" =~ ^[0-9a-zA-Z:]+$ ]]
    then
	ip_address="[$ip_address]"
    fi

    if [ -n "$ip_address" ]
    then
	printf "$ip_address"
	return 0

    else
	return 1
    fi
}

function dcc_xfer {
    local offset old_offset pid_cat
    unset resume

    check_dcc_resume && resume=true

    exec 4<>/dev/tcp/${ctcp[address]}/${ctcp[port]} &&
	{
	    if [ -n "$resume" ]
	    then
		unset resume
		cat <&4 >>"$file_in" &
		pid_cat=$!

	    else
		cat <&4 >"$file_in" &
		pid_cat=$!
	    fi
			
	    if [ -n "$pid_cat" ]
	    then
		print_c 1 "$(gettext "Connected to the address"): ${ctcp[address]}:${ctcp[port]}"
                del_pid_url "$url_in" "irc-wait"
                
		set_mode "daemon"
		echo "$url_in"  >"$file_in.zdl"
		add_pid_url "$pid_cat" "$url_in" "xfer-pids"
					
		while [ ! -f "$path_tmp/${file_in}_stdout.tmp" ]
		do
		    sleep 0.1
		done
		sed -r "s,____PID_IN____,$pid_cat,g" -i "$path_tmp/${file_in}_stdout.tmp"

	    else
                del_pid_url "$url_in" "irc-wait"
		irc_quit
	    fi
            
            

            this_mode=daemon
	    while [ ! -f "${file_in}" ]
	    do
		sleep 0.1
	    done

	    while check_pid "$pid_cat" && [ "$offset" != "${ctcp[size]}" ]
	    do
		[ -f "$path_tmp/irc-timeout" ] &&
		    ! grep -P "^$url_in$" "$path_tmp/irc-timeout" &>/dev/null &&
		    echo "$url_in" >>"$path_tmp/irc-timeout"
		
		offset=$(size_file "$file_in")
		[ -z "$offset" ] && offset=0
		[ -z "$old_offset" ] && old_offset=$offset
		(( old_offset > offset )) && old_offset=$offset
		
		printf "XDCC %s %s %s XDCC\n" "$offset" "$old_offset" "${ctcp[size]}" >>"$path_tmp/${file_in}_stdout.tmp"

		if [[ "$(head -n2 "$path_tmp/${file_in}_stdout.tmp" |tail -n1)" =~ ^XDCC ]] ||
		       [[ "$file_in" =~ XDCC' ' ]]
		then		    
		    kill -9 "$pid_cat"
		    rm -f "$path_tmp/${file_in}_stdout".*
		fi
		old_offset=$offset

		## (offset - old_offset /1024) KB/s --> sleep 1 (ogni secondo)
		sleep 1
	    done

	    if [ "$(size_file "$file_in")" == "${ctcp[size]}" ]
	    then
		rm -f "${file_in}.zdl"
		set_link - "$url_in"
	    fi

	    irc_quit
	}
}

function join_xdcc_send {
    local line="$1"
    local msg
    
    if [[ "$line" =~ (MODE ${irc[nick]}) ]] &&
	   [ -n "${irc[chan]}" ]
    then
	print_c 1 "$line"
	
	irc_send "JOIN #${irc[chan]}"
	print_c 2 ">> JOIN #${irc[chan]}"
    fi

    if [[ "$line" =~ (JOIN :) ]] &&
	   [ -n "${irc[msg]}" ]
    then
	unset irc[chan]

	print_c 1 "<< $line"

	read -r to msg <<< "${irc[msg]}"

	echo "$to $url_in" >>"$path_tmp"/irc_xdcc
	#xdcc_cancel
	#sleep 3

        irc_send "PRIVMSG $to" "$msg"
	print_c 2 ">> PRIVMSG $to :$msg"
	
	unset irc[msg]
    fi

    if [[ "$line" =~ 'Join #'([^\ ]+)' for !search' ]]
    then
	chan="${BASH_REMATCH[1]}"
    	print_c 2 ">> JOIN #${chan}"
    	irc_send "JOIN #${chan}"
    fi
}

function send_xdcc {
    read -r to msg <<< "${irc[msg]}"
    echo "$to $url_in" >>"$path_tmp"/irc_xdcc
    
    irc_send "PRIVMSG $to" "$msg"
    print_c 2 ">> PRIVMSG $to :$msg"
    irc_send "zdl_irc_client$to"

    # check_line_regex "$line"
    # check_irc_command "$irc_cmd" "$txt"
}

function check_irc_command {
    local cmd="$1"
    local txt="$2"
    
    case "$cmd" in
	PING)
	    unset chunk
	    if [ -n "$txt" ]
	    then
		chunk=":$txt"

	    else
		chunk="${irc[nick]}"
	    fi
	    ## print_c 2 "PONG $chunk"
	    irc_send "PONG $chunk"
	    ;;
	NOTICE)
	    check_notice "$txt"
	    print_c 4 "<< $txt"
	    ;;
	PRIVMSG)
	    if check_ctcp "$txt"
	    then
		file_in="${ctcp[file]}"
		sanitize_file_in
		
		url_in_file="/dev/tcp/${ctcp[address]}/${ctcp[port]}"
		echo -e "$file_in\n$url_in_file" >"$test_xfer"

echo "creato $test_xfer"
cat "$test_xfer"
		
		while [ ! -f "$path_tmp/${file_in}_stdout.tmp" ]
		do
                    echo "file mancante: $path_tmp/${file_in}_stdout.tmp" 
                    sleep 0.1
		done
		
		dcc_xfer &
		pid_xfer=$!			
		add_pid_url "$pid_xfer" "$url_in" "xfer-pids"
	    fi
	    ;;
    esac
}

function check_line_regex {
    local line="$1"

    if [[ "$line" =~ zdl_irc_client(.+)' :.+' ]]
    then
        ctcp_src="${BASH_REMATCH[1]}"
        print_c 4 "$ctcp_src"
    fi
    
    if [[ "$line" =~ (${to//\|/\\\|}\ *:No such nick\/channel) ]]
    then
	notice="${BASH_REMATCH[1]}"
	_log 27
	irc_quit
    fi
}

function set_irc_fifo {
    local pid_irc="$1" pid_fifo="$2" fifo="$3"

    if check_pid "$pid_irc" &&
            check_pid "$pid_fifo" &&
            test -p "$fifo"
    then
        return 1
    else
        mkfifo "$fifo"
        echo "$pid_irc $pid_fifo $fifo" >> "$path_tmp/irc-conn"
        return 0
    fi
}

function check_irc_fifo {
    local fifo="$1" ret=0

    test -p "$fifo" || return 1

    if test -s "$path_tmp/irc-conn"
    then
        while read -a line
        do
            if ! ( check_pid "${line[0]}" &&
                       check_pid "${line[1]}" &&
                       [ "$fifo" == "${line[2]}" ] )
            then
                kill -9 "${line[0]}" 2>/dev/null
                kill -9 "${line[1]}" 2>/dev/null
                rm -f "${line[2]}"
                ret=1
            fi
                
        done < "$path_tmp/irc-conn"

        if [ "$ret" == 1 ]               
        then
            grep -vP " $fifo$"  "$path_tmp/irc-conn" >"$path_tmp/irc-conn.new"
        else
            mv "$path_tmp/irc-conn" "$path_tmp/irc-conn.new"
        fi
        awk '!($0 in a){a[$0]; print}' "$path_tmp/irc-conn.new" > "$path_tmp/irc-conn"

    else
        rm -f "$fifo"
        ret=1
    fi

    return $ret
}

function set_irc_queue {
    local u new
    url "$1" &&
        u="$1" ||
            u="$url_in"
    
    if test -s "$path_tmp/irc-queue"
    then
        new=$(grep -v "$u" "$path_tmp/irc-queue")
        echo "$new" >"$path_tmp/irc-queue"
    fi

    echo "$u" >>"$path_tmp/irc-queue"
}

function irc_client {
    local line user from txt irc_cmd conn ppp
    dev_host="/dev/tcp/${irc[host]}/${irc[port]}"
    local msg_fifo="${irc[msg]%\|*}"
    msg_fifo="${msg_fifo// }"
    msg_fifo="${msg_fifo//\|}"
    dev_fifo=/tmp/"${irc[host]//\/}-${irc[chan]//\/}-$msg_fifo"

    check_irc_fifo "$dev_fifo"
    
    while read ppp 
    do
        check_pid_url "$ppp" "${url_in%%msg*}" "irc-fifo-pid" ||
            local remove=true

    done< <(get_pid_url "${url_in%%msg*}" "irc-fifo-pid")

    [ "$remove" == true ] && rm -rf "$dev_fifo"

    if [ -p "$dev_fifo" ]
    then
        until test -p "$dev_fifo"
        do
            sleep 0.1
        done

        set_irc_queue "$url_in" "fifo"
        exec 3<>"$dev_fifo"
        send_xdcc
        del_pid_url "$url_in" "irc-wait"

        return 0
        
    else
        set_irc_queue "$url_in" "host"
        
        if exec 3<>"$dev_host"
        then
	    print_c 1 "host: ${irc[host]}\nchan: ${irc[chan]}\nmsg: ${irc[msg]}\nnick: ${irc[nick]}"
            
	    irc_send "NICK ${irc[nick]}"
	    irc_send "USER ${irc[nick]} localhost ${irc[host]} :${irc[nick]}"

            while :
            do
                test -p "$dev_fifo" &&
                    cat "$dev_fifo" >&3
                
            done &
            pid_fifo=$!
            disown $pid_fifo
            
	    while read line
	    do
                get_mode

	        line=$(tr -d "\001\015\012" <<< "${line//\*}")

	        if [ "${line:0:1}" == ":" ]
	        then
		    from="${line%% *}"
		    line="${line#* }"
	        fi

	        # from="${from:1}"
	        # user=${from%%\!*}
	        txt=$(trim "${line#*:}")
	        irc_cmd="${line%% *}"

	        join_xdcc_send "$line" 

	        ## per ricerche e debug:
                print_c 4 "$line"

	        check_line_regex "$line"

	        check_irc_command "$irc_cmd" "$txt"

            done <&3 &
	    irc_pid=$!
            disown "$irc_pid"

            until check_pid "$irc_pid"
            do sleep 0.1
            done
            
            set_irc_fifo "$irc_pid" "$pid_fifo" "$dev_fifo" &&
                print_c 4 "FIFO: $dev_fifo"
            
	    add_pid_url "$irc_pid" "$url_in" "irc-loop-pids"
	    #echo "$irc_pid" >>"$path_tmp/external-dl_pids.txt"
            add_pid_url "$PID" "$url_in" "irc-wait"

            #wait "$irc_pid"        
	    return 0
        
        else
            return 1
        fi
    fi
}



################ main:
PID=$$

set_mode "stdout"
this_tty="$7"


#errors=$(grep -P '(743|883|878|879|890|891|1124|1131|1381|1382|1775|1776|1777|1778)' $path_usr/irc/* -h) # |cut -d'"' -f2 |cut -d'%' -f1)

errors_again=$(grep -P '(743|883|890|891|1124|1131|1381|1382|1775|1776|1777|1778)' $path_usr/irc/* -h)
errors_stop=$(grep -P '(878|879)' $path_usr/irc/* -h)

declare -A ctcp
declare -A irc

irc=(
    [host]="$1"
    [port]="$2"
    [chan]="$3"
    [msg]="$4"
    [nick]="$5"
)

test_xfer="${irc[msg]##*\|}"
test_xfer="${test_xfer%% *}"
test_xfer="$path_tmp/${irc[nick]}${test_xfer}${irc[msg]##*\#}" 

echo "irc_client test_xfer: $test_xfer"

url_in="$6"
add_pid_url "$PID" "$url_in" "irc-pids"
start_timeout
init_resume
add_pid_url "$PID" "$url_in" "irc-client-pid"

exec 3>&-

irc_client ||
    {
        echo "irc_client restituisce eccezione/errore"
	touch "$test_xfer"
	_log 26
	exec 3>&-

	if [ -d /cygdrive ]
	then
	    kill -9 $(children_pids $PID)
	    
	else
	    kill -9 $(ps -o pid --no-headers --ppid $PID)
	fi
    }

